# Question

What is the difference between how instance methods/properties and class methods/properties are created? What is the difference between how they are used?

# Answer

Private and public properties/methods of an instance can be initialized/given value *inside* the constructor of a class. However, **static** properties are initialized inside the scope of the class, and not the class constructor, which makes it exclusive to the class.  

Class properties and methods are used to get/present information from every instance made using that class constructor. 




```js

class FamilyPet = {
    static breed = "Beagle";
    #allDogs = [];

    constructor (name, height, weight, favoriteToy, favoriteTreat) {
        this.petName = name,
        this.petHeight = height,
        this.petWeight = weight,
        this.petToy = favoriteToy,
        this.petTreat = favoriteTreat
    };

    addToFamilyHistory() {
        FamilyPet.#allDogs.push(this.petName)
        return [...#allDogs]
    };

    getName() {
        return this.petName
    };

    getMedicalInfo() {
        return [{`${this.petHeight}`}, {`${this.petWeight}`}]
    };

    getToy() {
        return this.petToy
    };

    giveTreat() {
        return `You gave ${this.petName} a ${this.favoriteTreat}!`
    }

}

```

# Teacher Feedback

1/3
The code example you wrote was good. Your answer contains some useful points, but there are some inaccuracies.

- Instance methods and properties are defined in the constructor function of a class. Each instance of the class has its own copy of these methods and properties.

```js

class Dog {
  constructor(name) {
    this.name = name; // Instance property
  }
  
  bark() { // Instance method
    console.log(`${this.name} barks!`);
  }
}

```

>_note_: the `class` keyword is abstracting the constructor function, which saves the class itself in memory. More on this in a bit.

If you are making class objects using the constructor function syntax you would use the `prototype` to define instance methods like this:

```js

Dog.prototype.bark = function() { // Instance method
  console.log(`${this.name} barks!`);
}

```

- Class methods and properties (static methods and properties) are defined directly on the class itself; it does not have to come before a `constructor()`. A class does not need to use the `constructor()`

```js

class Dog {
  static species = 'Canine'; // Static property
  
  static description() { // Static method
    return `All dogs are ${this.species}.`;
  }
}

```

- how they are used:

Class methods/properties:

```js

console.log(Dog.species); // Canine
console.log(Dog.description()); // All dogs are Canine.

```

You use them directly on the class

---

Instance method/properties:

```js
const myDog = new Dog('Rex');
myDog.bark(); // Rex barks!
console.log(myDog.name); // Rex
```

You use them on the instance that was created from the class.

- To break this down all the way:

Classes are essentially syntactic sugar over constructor functions.

```js
// all together
class Dog {
  constructor(name) {
    this.name = name; // Instance property
  }
  
  bark() { // Instance method (on prototype)
    console.log(`${this.name} barks!`);
  }
  
  static species = 'Canine'; // Static property
  
  static description() { // Static method
    return `All dogs are ${this.species}.`;
  }
}
// We create a new instance of the class when we use the `new` keyword
const myDog = new Dog('Rex');
console.log(myDog.name); // Output: Rex
myDog.bark(); // Output: Rex barks!

console.log(Dog.species); // Output: Canine
console.log(Dog.description()); // Output: All dogs are Canine.

```

When compiled, the `class` will be saved in memory like a blueprint of how to build instances from that class when we use the `new` keyword. The static methods/properties will be saved on the class itself. The instance methods will be added to the `prototype` property of the class. We can see how this breaks down without the class syntax below.

```js
const Dog = (name) => { // Constructor functions
  this.name = name; // Instance property
}

Dog.prototype.bark = function() { // Instance method (on prototype)
  console.log(`${this.name} barks!`);
};

Dog.species = 'Canine'; // Static property

Dog.description = function() { // Static method
  return `All dogs are ${this.species}.`;
};

const myDog = new Dog('Rex');
console.log(myDog.name); // Output: Rex
myDog.bark(); // Output: Rex barks!

console.log(Dog.species); // Output: Canine
console.log(Dog.description()); // Output: All dogs are Canine.

```

- There was no need to mention super and sub classes for this question.